<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Array</title>
</head>

<body>
    <script>
    // 1.创建
    // 括号里面一个数字表示数组长度
    var arr1 = new Array(1);
    // 括号里面超过一个数字表示真实的数组
    var arr2 = new Array(1, 23);

    console.log(arr1)
    console.log(arr1.length)
    console.log(arr2)
        // new可省略
        // 也可以
    var arr3 = [1, 2];
    // 最后一个元素后面不要,




    // 2.访问
    // arr[index] 返回该索引的元素 
    // arr.slice(startIndex,endIndex) 返回相应索引元素组成的数组
    console.log(arr3[0])
    console.log(arr3.slice(0, 1))




    // 3.添加和删除元素(以下均改变原数组)
    // push,pop,unshift,shift,splice,length
    // 末尾处加删元素
    var arr4 = [1, 23, 4, 5, 6];
    // push在数组后面加一个或多个元素,并返回增加后的长度
    // push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。合并数组说这个
    console.log(arr4.push(1, 2, [3, 4], [5, 6]));
    console.log(arr4);
    // pop 在数组后面删除一个元素,并返回删除的元素
    console.log(arr4.pop());
    console.log(arr4);

    // 开头处加删元素
    // unshift 在数组前面加一个或多个元素,并返回增加后的长度
    console.log(arr4.unshift(-1, -2, [-1, -2]));
    console.log(arr4);
    // shift 在数组前面删除一个元素,并返回删除的元素
    console.log(arr4.shift());
    console.log(arr4);
    // 任意处加删元素,或替换元素
    // splice(deleteStartIndex,deleteNum,addValueInDeLeteStartIndex,addValue2,addValue3.........),返回删除的元素组成的数组,前两个是必选参数
    var arr5 = [0, 1, 2, 3, 4];
    // 单纯增加元素的话,第二个参数为0
    console.log(arr5.splice(1, 0, 'a', 'b'))
    console.log(arr5)
        // 单纯删除元素的话,只写两个参数
    console.log(arr5.splice(0, 1))
    console.log(arr5)
        // 单纯替换元素的话,第二个参数和增加的值数量一致
    console.log(arr5.splice(1, 2, 'replace1', 'replace2'));
    console.log(arr5);
    // length  只能删除后面的元素或者在后面添加元素,毕竟人家只能控制长度
    arr5.length = 1;
    console.log(arr5);
    // 下面是变相的加一个元素
    arr5[arr5.length] = 3;




    // 数组合并
    // concat()和push()
    // Array.concat(para);// para 可以为数组或元素值，也可以为两者组合，将所有元素连接成一个数组，返回连接好的数组；
    var arr6 = ['hell'];
    var arr7 = ['o'];
    var arr8 = arr6.concat(arr7, ['h', 'i'], 'bun', 'guagua');
    console.log(arr8);
    // concat()连接小的数组
    // push()可以用于大数组,且会改变原数组
    var arr9 = Array.prototype.push.call(arr6, arr7, 8, 9, 10, [1, 2]);
    console.log(arr9);
    console.log(arr6);


    // 字符串化
    // join,toString,toLocaleString
    // arr.join(spliter)默认是逗号,可选参数,不改变数组,返回字符串
    // 后面两个相当于join(","),不常用
    var arr10 = ['i ', 'want ', 'to ', 'sleep'];
    console.log(arr10.join(""));
    console.log(arr10.join(" insert "));
    console.log(arr10.join());
    console.log(arr10.toString());
    console.log(arr10.toLocaleString());



    // 排序
    // reverse() 颠倒数组元素,返回一个颠倒的数组,且改变原数组
    // sort(fn) 按某种方式排序,默认是按字符大小从小到大排序
    var arr11 = [3, 4, 5, 6, 7, 11];
    console.log(arr11.reverse());
    console.log(arr11);
    console.log(arr11.sort());
    // 数字从小到大排序
    console.log(arr11.sort(function(a, b) {
        return a - b;
    }));
    // 随机打乱数组
    console.log(arr11.sort(function() {
        return Math.random() - 0.5
    }));



    // 查找某个元素是否存在数组中,并返回找到的话返回相应索引
    // indexOf(),lastIndexOf()
    // indexOf(item),从第一个元素开始寻找,找到返回相应的索引,找不到返回-1
    // lastIndexOf(item),从倒数第一个元素开始寻找,找到返回相应的索引,找不到返回-1
    var arr12 = ["a", "b", "c"];
    console.log(arr12.indexOf("b"));
    console.log(arr12.indexOf("d"));
    console.log(arr12.lastIndexOf("c"));




    // 判断是否是数组
    // Array.isArray(arrDetemine)
    var arrF = "f";
    var arrT = [];
    console.log(Array.isArray(arrF));
    console.log(Array.isArray(arrT));




    // 高级应用:遍历迭代
    // 循环(loop) - 最基础的概念, 所有重复的行为
    // 递归(recursion) - 在函数内调用自身, 将复杂情况逐步转化成基本情况
    // (数学)迭代(iterate) - 在多次循环中逐步接近结果
    // (编程)迭代(iterate) - 按顺序访问线性结构中的每一项
    // 遍历(traversal) - 按规则访问非线性结构中的每一项
    // 这些概念都表示“重复”的含义, 彼此互相交叉, 在上下文清晰的情况下, 不必做过于细致的区分.
    // forEach,map,filter,every,some
    // array.forEach(callback[, thisArg])
    // callback 函数会被依次传入三个参数：数组当前项的值,数组当前项的索引,数组对象本身
    // thisArg是可选参数,表示this所指的方向
    // 如果给forEach传递了thisArg 参数，它将作为 callback 函数的执行上下文，类似执行如下函数callback.call(thisArg, element, index, array)
    // forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。

    // 注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every 或 Array.some。
    // forEach 为数组中的元素执行一次 callback 函数，不像 every 和 some，它总是返回 undefined。
    var arr13 = ['a', 'b', 'c', 'd'];
    var sum = "";
    var foreachValue = arr13.forEach(function(currentVal, index, array) {

        console.log('currentVal: ' + currentVal + ' , index: ' + index + ',array: ' + array + '    ')
        sum += currentVal

    });
    console.log(foreachValue);
    console.log(sum);

    // array.map(callback[, thisArg]),map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。
    // thisArg执行 callback 函数时 this 指向的对象。
    var plural = function(single) {
        if (single === 'foot') {
            single = single.replace(/o/g, 'e')
        } else {
            single += "s";
        }

        return single;
    }
    var arr14 = ["apple", 'dog', 'cat', 'foot'];
    console.log(arr14.map(plural));
    console.log(arr14);

    // arr.filter(callback[, thisArg])
    // filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。
    // 用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。
    // 返回true表示保留该元素（通过测试），false则不保留。
    var isEnoughBig = function(curVal, index) {
        curVal += index;
        if (curVal > 10) {

            return true;
        }

    }
    var arr15 = [12, 9, 1, 23, 45, 6, 7, 1];
    console.log(arr15.filter(isEnoughBig)); // 仅仅是过滤不会改变原数组中的值
    console.log(arr15);

    // arr.every(callback[, thisArg])
    // 测试数组的所有元素是否都通过了指定函数的测试。只有都通过测试才是返回true,否则是false
    // 不改变原数组
    var arr16 = [1, 23, 34];
    var arr17 = [13, 23, 34];
    console.log(arr16.every(isEnoughBig));
    console.log(arr17.every(isEnoughBig));


    // arr.some(callback[, thisArg])
    // some() 方法测试数组中的某些元素是否通过了指定函数的测试。只要有一个通过测试就返回true,否则是false
    // 不改变原数组
    var arr18 = [1, 2, 3]
    console.log(arr16.some(isEnoughBig));
    console.log(arr17.some(isEnoughBig));
    console.log(arr18.some(isEnoughBig));



    // 其他方法
    // reduce(),reduceRight(),from()
    // arr.reduce(callback,[initialValue])
    // reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。
    // callback
    // 执行数组中每个值的函数，包含四个参数
    // previousSum
    // 上一次调用回调返回的值，或者是提供的初始值（initialValue）
    // currentValue
    // 数组中当前被处理的元素
    // index
    // 当前元素在数组中的索引
    // array
    // 调用 reduce 的数组
    // 回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。
    // 如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。
    var arr19 = [0,1,2,3,4,5,6];
    var sum = arr19.reduce(function(prevSum,cur,index){
    	return prevSum+cur+index;
    },10)
    console.log(sum);
    var sum1 = arr19.reduce(function(prevSum,cur,index){
    	return prevSum+cur+index;
    })
    console.log(sum1);
    // reduceRight()从后面开始............
    // Array.from(arrLike) ,类似于args,nodelist转化为数组,不多说

  

    </script>
</body>

</html>
