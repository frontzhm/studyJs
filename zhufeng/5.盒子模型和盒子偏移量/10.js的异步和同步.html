<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
      
        // js是单线程的 做着一件事 不做完 不开始下一个
        // js的两种编程思想:同步 异步
        // 1.同步:上一件事情只有完成才开始下一件事情(js大部分都是同步编程的)
        // for(var i=0;i<1000;i++){
        //     if(i===999){
        //         console.log('end')
        //     }
        // } // (1)
        // console.log('ok') //(2)
        // for循环是同步编程的 只有循环结束 才执行下面的
        // 2.异步:规划做一件事情 但是不是当前立马执行这件事 需要等一定时间,这样的话 我们不会等着它执行 而是执行下面的代码 "只有当下面的代码执行完了 才会返回执行处理之前的事情 如果下面的没执行完 那么不管之前的事情有没有到时间 都必须等着"
        // 在js中异步编程四种情况:定时器是异步编程的 所有的事件绑定,ajax读取数据的时候 我们一般为异步编程 回调函数也是异步
        // var n=0;
        // setTimeout(function (argument) {
        //      n++;
        //      console.log(n) // 1 (2)
        // }, 1000)
        // console.log(n)  // 0 (1)
        // 先执行下面的console.log(n)  执行完之后 一直等到执行上面的时候 因为下面的代码执行<1s所以是能按时执行的
        // var n=0;
        // setTimeout(function (argument) {
        //      n++;
        //      console.log(n) // 1 (2)
        // }, 0)
        // console.log(n)  // 0 (1)
        // 每一个浏览器对定时器都有一个最小等待时间 如果设置的等待时间小于这个时间 也是最小值 ,尤其是0也是一样滴
        // var n=0;
        // setTimeout(function (argument) {
        //      n++;
        //      console.log(n) // 不执行
        // }, 0)
        // console.log(n)  // 0 (1)
        // while (1) {  // 死循环(2)
        //     n++
        // }
        // console.log(n) // 不执行
        // 定时器设置的等待时间 不一定就是最好执行的时间 如果定时器之后的事情正在处理中 不管定时器的时间有没有到 都是不会执行定时器的
        // var n=0;
        // setTimeout(function () {
             
        //      n+=2; 
        //      console.log(n)  // 7 (5) 
        // }, 100)
        // setTimeout(function () {
             
        //      n+=5;
        //      console.log(n) // 5 (4)   
        // }, 50)
        // console.log(n) // 0 (1)
        // for(var i=0;i<10000;i++){} // (2)
        // console.log(n) // 0  (3)
        // 换第一个定时器的时间
    // var n=0;
    // setTimeout(function () {
         
    //      n+=2; 
    //      console.log(n)  // 2 (4) 
    // }, 10)
    // setTimeout(function () {
         
    //      n+=5;
    //      console.log(n) // 7 (5)   
    // }, 50)
    // console.log(n) // 0 (1)
    // for(var i=0;i<10000;i++){} // (2)
    // console.log(n) // 0  (3)
    


    // for(var i=0;i<lis.length;i++){
    //     lis[i].onclick = function () {
    //          console.log(i) 
    //     }
    //     // 不等点击 一直执行循环 等到点击的时候 循环完毕 i=5...
    // }
    </script>
</body>
</html>