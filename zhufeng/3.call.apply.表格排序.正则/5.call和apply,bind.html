<html>

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script>
  var obj = {name:"hua"};
  function fn (num1,num2) {
     console.log(num1+num2,this)
  }
  // fn(100,200) // 300 window
  // fn.call(100,200) //NaN 100
  // fn.call(obj,100,200) //300 obj
  fn.call() //此时fn里面的this并没有改变,window
  fn.call(null) //此时fn里面的this并没有改变,window
  fn.call(undefined)//此时fn里面的this并没有改变,window
  // 严格模式下 ()里什么就是什么 什么都不写就是undefined
  "use strict"
  // apply和call的作用是一样的,都是用来改变方法的this的关键字,并且执行;并且在严格模式和非严格模式下的规律是一样的
  fn.call(obj,100,200);// call是一个一个传
  fn.apply(obj,[100,200]);// apply是把参数统一放在一个数组中进行操作,但是也相当于一个个的给fn的形参赋值
  // bind在ie6-8不兼容 
  // 和call apply类似,都是用来改变this的关键字
  fn.call(obj,1,2) //改变this和执行fn函数是一起完成的
  // 预处理:实现把fn的this改变为我们想要的结果,并且把对应的参数值也准备好,以后要用到了,直接的执行即可
  var tempFn = fn.bind(obj,1,2)// 只是改变了this,并且传递了两个参数,但此时函数并未执行
  tempFn() // 执行bind会有一个返回值,就是fn改变后this的那个结果

  // 非严格模式下this
  // 1.自执行函数 window
  // 2.元素绑定事件的this指元素
  // 3.x.fn() 点前面是谁this就是谁
  // 4.构造函数的this指实例
  // 5.call,apply,bind
  // 
  // 
  // 严格模式下this
  // 1.自执行函数 undefined
  // 2.方法执行 有点,this就是点前面的,没点就是undefined
  // 严格模式下的this和非严格模式下的this区别:
  // 非..,this默认指的是window
  // 严..,this默认指的是undefined
  // 
  // 
  // 遇到this一定冷静思考3s
    </script>
</body>

</html>
