<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>

<body>
  <script>
  // 引用类型:function object


  /*		function createJsPerson(name,age){
  			var obj ={};
  			obj.name = name;
  			obj.age=age;
  			obj.writeJs = function(){
  				console.log("my name is "+name+" i can write js")
  			};
  			return obj;
  		}
  		var p1 = createJsPerson("花花",18);
  		p1.writeJs();*/

  // 构造函数模式的目的是为了创建一个自定义类,并且创建这个类的实例
  /*function CreateJsPerson(name,age){
  	var obj ={};
  	obj.name = name;
  	obj.age=age;
  	obj.writeJs = function(){
  		console.log("my name is "+name+" i can write js")
  	};
  	return obj;
  }
  var p1 = new CreateJsPerson("花花",18);
  p1.writeJs();*/
  // 构造函数和工厂模式的区别:
  // 1.执行的时候
  // 普通函数执行 -> createJsPerson()
  // 构造函数模式 -> new CreateJsPerson() 通过new执行后,我们的CreateJsPerson就是一个类了
  // 而函数执行的返回值(p1)就是CreateJsPerson这个类的一个实例
  // 
  function CreateJsPerson(name, age) {
    // 浏览器默认的创建的对象就是我们的实例P1 ->this
    this.name = name;
    this.age = age;
    this.writeJs = function() {
      console.log("my name is " + name + " i can write js")
    };
  }
  var p1 = new CreateJsPerson("花花", 18);
  p1.writeJs();
  // 2.在函数代码执行的时候
  // 相同点:都是形成一个私有作用域,然后经历形参赋值->预解释->代码从上到下执行(类和普通函数一样,它也有普通函数的一面)
  // 不同点:在代码执行之前,不用自己在手动的创建对象了,浏览器会默认的创建一个对象数据类型的值(这个对象其实就是我们当前类的一个实例)
  // 接下来代码从上往下执行,以当前的实例为执行主体(this代表的就是当前的实例),然后分别把属性和属性值赋给当前的实例
  // 最后浏览器会默认的把创建的实例返回


  // 创建数组
  var arr = []; // 字面量方式
  var arr1 = new Array(); // 实例创建的方式 -> 构造函数模式执行的方式 
  // 不管哪种方式 arr都是Array这个类的一个实例
  // 
  // 
  // 1.
  // js中所有的类都是函数数据类型,它通过new执行,变成一个类,但是它本身也是普通的函数
  // js中所有的实例都是对象数据类型的
  // 2.
  // 在构造函数模式中,类中(函数体中)出现的this.x =x中的this是当前类的一个实例
  </script>
</body>

</html>
